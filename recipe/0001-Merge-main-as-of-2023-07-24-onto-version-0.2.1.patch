From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ryan Volz <ryan.volz@gmail.com>
Date: Fri, 16 Feb 2024 10:54:12 -0500
Subject: [PATCH] Merge main as of 2023-07-24 onto version 0.2.1

Squashed commit of the following:

commit b906b27e6820fe44fcc3527cc876771f7dac85d2
Author: AlexeyBarsuk <barsuk.alexey@gmail.com>
Date:   Mon Jul 24 21:00:34 2023 +0300

    Fic src increment for rx_streamer.recv on non direct-copy (#57)

commit a07c37230369653818b3a5c448c00cee1ac9f8e5
Author: Christian W. Zuckschwerdt <christian@zuckschwerdt.org>
Date:   Sun Jul 10 09:48:34 2022 +0200

    Update docs with xo_correction note

commit 04943ed34257bc2482f72fbb3622ed9a01f5c749
Author: Christian W. Zuckschwerdt <christian@zuckschwerdt.org>
Date:   Sat Jul 2 11:48:14 2022 +0200

    Fix libusb linking typo

commit ceb63bad8cede78c75fa0fb478818a1eb95cf06b
Author: Florian Euchner <norrepli@gmail.com>
Date:   Fri Jul 1 17:51:18 2022 +0200

    Add uri key to match devices, ensure that libiio context is a PlutoSDR (#42)

    * Respect specified `uri` when searching for devices
    * Ensure that discovered libiio context is a PlutoSDR

    Fixes #37

    Co-authored-by: Christian W. Zuckschwerdt <zany@triq.net>

commit a99d325ef2383b850350084e489542790580771f
Author: Christian W. Zuckschwerdt <zany@triq.net>
Date:   Fri Jul 1 17:35:57 2022 +0200

    Add libusb check for known ADALM-Pluto VID:PID (#50)

commit a2431282fc258c692374ebfed507ac558ae29b15
Author: Clayton Smith <argilo@gmail.com>
Date:   Mon Feb 7 08:53:22 2022 -0500

    Set label when PlutoSDR is USB-connected (#48)

commit 3eb276e8e86dcccd19630be419dc79b3d66028a0
Author: Clayton Smith <argilo@gmail.com>
Date:   Fri Feb 4 07:29:36 2022 -0500

    Disable automatic gain by default (#49)

commit 38a34f692a56c05e05bcb5ec9db96946b6086c8c
Author: Christian W. Zuckschwerdt <christian@zuckschwerdt.org>
Date:   Thu Sep 30 12:01:02 2021 +0200

    Add CS8 TX direct copy, fix CS12 TX direct copy

commit 28d4367e997441a7262af6d423a925a22cd4566b
Author: Christian W. Zuckschwerdt <christian@zuckschwerdt.org>
Date:   Tue Sep 28 16:58:03 2021 +0200

    Fix for backend scan errors

commit 4d0ea5acf20f2644c3789a9acbf4e5d51f622696
Author: Christian W. Zuckschwerdt <christian@zuckschwerdt.org>
Date:   Mon Sep 20 18:31:03 2021 +0200

    Fix undefined default warnings

commit c880222d5df06af08024dbd183eb610526edd1d1
Author: Christian W. Zuckschwerdt <christian@zuckschwerdt.org>
Date:   Tue May 25 19:23:01 2021 +0200

    Add getSampleRateRange() API

commit ca40ea9ab662d8f17d860c200891c8f94dff9504
Author: Christian W. Zuckschwerdt <christian@zuckschwerdt.org>
Date:   Sat May 1 12:04:13 2021 +0200

    Add PothosSDR note (closes #40)

commit 98e22135ed58c401003bfd265f83f0e8ad54b2e3
Merge: ac9a9da 33ba12d
Author: Josh Blum <josh@joshknows.com>
Date:   Sun Apr 25 15:42:46 2021 -0500

    Merge pull request #39 from willcode/add-uninstall-target

    Add uninstall target

commit 33ba12db14a75b40f8fc8713cbf98e70d40af93d
Author: Jeff Long <willcode4@gmail.com>
Date:   Sun Apr 25 10:20:36 2021 -0400

    Add uninstall target

    Signed-off-by: Jeff Long <willcode4@gmail.com>
---
 CMakeLists.txt                 |  50 +++++++---
 FindLibAD9361.cmake            |   9 +-
 FindLibIIO.cmake               |   1 +
 FindLibUSB.cmake               |  54 ++++++++++
 PlutoSDR_Registration.cpp      | 177 ++++++++++++++++++++++++---------
 PlutoSDR_Settings.cpp          |  25 ++++-
 PlutoSDR_Streaming.cpp         |  38 ++++---
 README.md                      |  11 ++
 SoapyPlutoSDR.hpp              |   3 +-
 cmake/cmake_uninstall.cmake.in |  21 ++++
 10 files changed, 307 insertions(+), 82 deletions(-)
 create mode 100644 FindLibUSB.cmake
 create mode 100644 cmake/cmake_uninstall.cmake.in

diff --git a/CMakeLists.txt b/CMakeLists.txt
index ea2eedc..7378003 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,15 +6,15 @@ project(SoapyPlutoSDR CXX)
 
 # select build type to get optimization flags
 if(NOT CMAKE_BUILD_TYPE)
-   set(CMAKE_BUILD_TYPE "Release")
-   message(STATUS "Build type not specified: defaulting to release.")
+    set(CMAKE_BUILD_TYPE "Release")
+    message(STATUS "Build type not specified: defaulting to release.")
 endif(NOT CMAKE_BUILD_TYPE)
 set(CMAKE_BUILD_TYPE ${CMAKE_BUILD_TYPE} CACHE STRING "")
 
 find_package(SoapySDR NO_MODULE)
- if (NOT SoapySDR_FOUND) 
-    message(FATAL_ERROR "Soapy SDR development files not found...") 
- endif () 
+if (NOT SoapySDR_FOUND)
+    message(FATAL_ERROR "Soapy SDR development files not found...")
+endif ()
 
 ########################################################################
 # Find libiio
@@ -31,7 +31,7 @@ endif()
 include_directories(${LibIIO_INCLUDE_DIRS})
 
 #enable c++11 features
-if(CMAKE_COMPILER_IS_GNUCXX)
+if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" OR "${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
 
     #C++11 is a required language feature for this project
     include(CheckCXXCompilerFlag)
@@ -39,20 +39,15 @@ if(CMAKE_COMPILER_IS_GNUCXX)
     if(HAS_STD_CXX11)
         set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
     else(HAS_STD_CXX11)
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")
+        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x -Wc++11-extensions")
     endif()
 
     #Thread support enabled (not the same as -lpthread)
     list(APPEND LibIIO_LIBRARIES -pthread)
 
     #disable warnings for unused parameters
-    add_definitions(-Wno-unused-parameter)
-endif(CMAKE_COMPILER_IS_GNUCXX)
-
-#enable c++11 extensions for OSX
-if (APPLE)
-   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x -Wc++11-extensions")
-endif(APPLE)
+    add_compile_options(-Wall -Wextra -pedantic -Wno-unused-parameter)
+endif()
 
 ########################################################################
 # Find libad9361
@@ -67,6 +62,21 @@ if (LibAD9361_FOUND)
     add_definitions(-DHAS_AD9361_IIO)
 endif()
 
+########################################################################
+# Find libusb
+########################################################################
+find_package(LibUSB)
+
+if(LibUSB_FOUND)
+    message(STATUS "LibUSB_INCLUDE_DIRS: ${LibUSB_INCLUDE_DIRS}")
+    message(STATUS "LibUSB_LIBRARIES: ${LibUSB_LIBRARIES}")
+    message(STATUS "LibUSB_DEFINITIONS: ${LibUSB_DEFINITIONS}")
+    include_directories(${LibUSB_INCLUDE_DIRS})
+    add_definitions(-DHAS_LIBUSB1)
+    #disable warnings for libusb.h
+    add_compile_options($<$<CXX_COMPILER_ID:GNU,Clang,AppleClang>:-Wno-zero-length-array>)
+endif()
+
 
 SOAPY_SDR_MODULE_UTIL(
     TARGET PlutoSDRSupport
@@ -74,5 +84,15 @@ SOAPY_SDR_MODULE_UTIL(
     PlutoSDR_Registration.cpp
     PlutoSDR_Settings.cpp
     PlutoSDR_Streaming.cpp
-    LIBRARIES ${LibIIO_LIBRARIES} ${LibAD9361_LIBRARIES}
+    LIBRARIES ${LibIIO_LIBRARIES} ${LibAD9361_LIBRARIES} ${LibUSB_LIBRARIES}
 )
+
+########################################################################
+# uninstall target
+########################################################################
+add_custom_target(uninstall
+    "${CMAKE_COMMAND}" -P "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake")
+configure_file(
+    "${CMAKE_CURRENT_SOURCE_DIR}/cmake/cmake_uninstall.cmake.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
+    IMMEDIATE @ONLY)
diff --git a/FindLibAD9361.cmake b/FindLibAD9361.cmake
index 9d5bc95..1567ad1 100644
--- a/FindLibAD9361.cmake
+++ b/FindLibAD9361.cmake
@@ -1,10 +1,11 @@
 # - Try to find libad9361-iio
 # Once done this will define
 #
-#  LibAD9361_FOUND - system has libiio
-#  LibAD9361_INCLUDE_DIRS - the libiio include directory
-#  LibAD9361_LIBRARIES - Link these to use libiio
-#  LibAD9361_DEFINITIONS - Compiler switches required for using libiio
+#  LibAD9361_FOUND - system has libad9361
+#  LibAD9361_INCLUDE_DIRS - the libad9361 include directory
+#  LibAD9361_LIBRARIES - Link these to use libad9361
+#  LibAD9361_DEFINITIONS - Compiler switches required for using libad9361
+#  LibAD9361_VERSION - the libad9361 version
 #
 # Redistribution and use is allowed according to the terms of the New BSD license.
 # For details see the accompanying COPYING-CMAKE-SCRIPTS file.
diff --git a/FindLibIIO.cmake b/FindLibIIO.cmake
index 638a384..4c0d536 100644
--- a/FindLibIIO.cmake
+++ b/FindLibIIO.cmake
@@ -5,6 +5,7 @@
 #  LibIIO_INCLUDE_DIRS - the libiio include directory
 #  LibIIO_LIBRARIES - Link these to use libiio
 #  LibIIO_DEFINITIONS - Compiler switches required for using libiio
+#  LibIIO_VERSION - the libiio version
 #
 # Redistribution and use is allowed according to the terms of the New BSD license.
 # For details see the accompanying COPYING-CMAKE-SCRIPTS file.
diff --git a/FindLibUSB.cmake b/FindLibUSB.cmake
new file mode 100644
index 0000000..e423527
--- /dev/null
+++ b/FindLibUSB.cmake
@@ -0,0 +1,54 @@
+# - Try to find LibUSB-1.0
+# Once done this will define
+#
+#  LibUSB_FOUND - System has libusb
+#  LibUSB_INCLUDE_DIRS - The libusb include directories
+#  LibUSB_LIBRARIES - The libraries needed to use libusb
+#  LibUSB_DEFINITIONS - Compiler switches required for using libusb
+#  LibUSB_VERSION - the libusb version
+#
+
+find_package(PkgConfig)
+pkg_check_modules(PC_LibUSB QUIET libusb-1.0)
+set(LibUSB_DEFINITIONS ${PC_LibUSB_CFLAGS_OTHER})
+
+find_path(LibUSB_INCLUDE_DIR NAMES libusb.h
+          HINTS ${PC_LibUSB_INCLUDE_DIRS}
+          PATH_SUFFIXES libusb-1.0
+          PATHS
+          /usr/include
+          /usr/local/include )
+
+#standard library name for libusb-1.0
+set(libusb1_library_names usb-1.0)
+
+#libusb-1.0 compatible library on freebsd
+if((CMAKE_SYSTEM_NAME STREQUAL "FreeBSD") OR (CMAKE_SYSTEM_NAME STREQUAL "kFreeBSD"))
+    list(APPEND libusb1_library_names usb)
+endif()
+
+#libusb-1.0 name on Windows (from PothosSDR distribution)
+if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
+    list(APPEND libusb1_library_names libusb-1.0)
+endif()
+
+find_library(LibUSB_LIBRARY
+             NAMES ${libusb1_library_names}
+             HINTS ${PC_LibUSB_LIBRARY_DIRS}
+             PATHS
+             /usr/lib
+             /usr/local/lib )
+
+set(LibUSB_VERSION ${PC_LibUSB_VERSION})
+
+include(FindPackageHandleStandardArgs)
+# handle the QUIETLY and REQUIRED arguments and set LibUSB_FOUND to TRUE
+# if all listed variables are TRUE
+find_package_handle_standard_args(LibUSB
+                                  REQUIRED_VARS LibUSB_LIBRARY LibUSB_INCLUDE_DIR
+                                  VERSION_VAR LibUSB_VERSION)
+
+mark_as_advanced(LibUSB_LIBRARY LibUSB_INCLUDE_DIR LibUSB_VERSION)
+
+set(LibUSB_LIBRARIES ${LibUSB_LIBRARY} )
+set(LibUSB_INCLUDE_DIRS ${LibUSB_INCLUDE_DIR} )
diff --git a/PlutoSDR_Registration.cpp b/PlutoSDR_Registration.cpp
index 65107da..a62e1b2 100644
--- a/PlutoSDR_Registration.cpp
+++ b/PlutoSDR_Registration.cpp
@@ -1,61 +1,148 @@
 #include "SoapyPlutoSDR.hpp"
 #include <SoapySDR/Registry.hpp>
+#include <sstream>
+#include <chrono>
+#include <thread>
+#ifdef HAS_LIBUSB1
+#include <libusb.h>
+#endif
 
 static std::vector<SoapySDR::Kwargs> results;
-static std::vector<SoapySDR::Kwargs> find_PlutoSDR(const SoapySDR::Kwargs &args){
+static std::vector<SoapySDR::Kwargs> find_PlutoSDR(const SoapySDR::Kwargs &args) {
 
-	if(!results.empty())
-	  return results;
+	if (!results.empty())
+		return results;
 
-	ssize_t ret=0;
-	iio_context *ctx=nullptr;
+	ssize_t ret = 0;
+	iio_context *ctx = nullptr;
 	iio_scan_context *scan_ctx;
 	iio_context_info **info;
 	SoapySDR::Kwargs options;
 
-	scan_ctx = iio_create_scan_context(NULL, 0);
-	char label_str[100];
-	//Skipping broken USB device
-	ret = iio_scan_context_get_info_list(scan_ctx, &info);
-	if(ret < 0) {
-		SoapySDR_logf(SOAPY_SDR_ERROR, "Unable to scan: %li\n", (long)ret);
-		iio_context_info_list_free(info);
-		iio_scan_context_destroy(scan_ctx);
-		return results;
-	}
-	options["device"] = "plutosdr";
-	if(ret == 0){
-		iio_context_info_list_free(info);
-		iio_scan_context_destroy(scan_ctx);
-
-		//no devices discovered, the user must specify a hostname
-		if (args.count("hostname") == 0) return results;
-
-		//try to connect at the specified hostname
-		ctx = iio_create_network_context(args.at("hostname").c_str());
-		if(ctx == nullptr) return results; //failed to connect
-		options["hostname"] = args.at("hostname");
-
-		sprintf(label_str, "%s #%d %s", options["device"].c_str(), 0, options["hostname"].c_str());
-		options["label"] = label_str;
-		results.push_back(options);
-		if (ctx != nullptr)iio_context_destroy(ctx);
-
-	}else{
-		for (int i = 0; i < ret; i++) {
-			ctx = iio_create_context_from_uri(iio_context_info_get_uri(info[i]));
-			if (ctx != nullptr) {
-				options["uri"] = std::string(iio_context_info_get_uri(info[i]));
-				sprintf(label_str, "%s #%d %s", options["device"].c_str(), i, options["uri"].c_str());
-				results.push_back(options);
-				if (ctx != nullptr)iio_context_destroy(ctx);
+	// Backends can error, scan each one individually
+	// The filtered "usb" backend is available starting from Libiio 0.24
+	std::vector<std::string> backends = {"local", "usb=0456:b673", "ip"};
+	for (std::vector<std::string>::iterator it = backends.begin(); it != backends.end(); it++) {
+
+		if (*it == "usb=0456:b673") {
+#ifdef HAS_LIBUSB1
+			// Abort early if no known ADALM-Pluto USB VID:PID (0456:b673) is found,
+			// that way we won't block USB access for other drivers' enumeration on Libiio before 0.24.
+			libusb_context *usb_ctx = nullptr;
+			int r = libusb_init(&usb_ctx);
+			if (r < 0) {
+				SoapySDR_logf(SOAPY_SDR_WARNING, "libusb init error (%d)\n", r);
 			}
+			else {
+				// This is what libusb_open_device_with_vid_pid(usb_ctx, 0x0456, 0xb673) does,
+				// but without actually opening a device.
+				struct libusb_device **devs;
+				// this is cached in libusb, we won't block USB access for other drivers
+				r = libusb_get_device_list(usb_ctx, &devs);
+				if (r < 0) {
+					SoapySDR_logf(SOAPY_SDR_WARNING, "libusb get device list error (%d)\n", r);
+					continue; // iio scan context will most likely fail too?
+				}
 
-	}
-		iio_context_info_list_free(info);
-		iio_scan_context_destroy(scan_ctx);
-	}
+				bool found = false;
+				struct libusb_device *dev;
+				size_t i = 0;
+				while ((dev = devs[i++]) != NULL) {
+					struct libusb_device_descriptor desc;
+					// this is cached in libusb, we won't block USB access for other drivers
+					r = libusb_get_device_descriptor(dev, &desc);
+					if (r < 0) {
+						break;
+					}
+					if (desc.idVendor == 0x0456 && desc.idProduct == 0xb673) {
+						found = true;
+						break;
+					}
+				}
+
+				libusb_free_device_list(devs, 1);
+
+				if (found) {
+					SoapySDR_logf(SOAPY_SDR_DEBUG, "ADALM-Pluto VID:PID found");
+				}
+				else {
+					SoapySDR_logf(SOAPY_SDR_DEBUG, "No ADALM-Pluto VID:PID found");
+					continue;
+				}
+			}
+#endif
+			// Defer to other drivers, prevent a race condition on USB enumeration with Libiio before 0.24,
+			// the value of 500ms has not been confirmed and might be 50ms to 1s possibly.
+			std::this_thread::sleep_for(std::chrono::milliseconds(500));
+		}
+
+		scan_ctx = iio_create_scan_context(it->c_str(), 0);
+		if (scan_ctx == nullptr) {
+			SoapySDR_logf(SOAPY_SDR_WARNING, "Unable to setup %s scan\n", it->c_str());
+			continue;
+		}
+
+		info = nullptr;
+		ret = iio_scan_context_get_info_list(scan_ctx, &info);
+		if (ret < 0) {
+			SoapySDR_logf(SOAPY_SDR_WARNING, "Unable to scan %s: %li\n", it->c_str(), (long)ret);
+			iio_context_info_list_free(info);
+			iio_scan_context_destroy(scan_ctx);
+			continue;
+		}
+
+		options["device"] = "PlutoSDR";
+		if (ret == 0) {
+			iio_context_info_list_free(info);
+			iio_scan_context_destroy(scan_ctx);
 
+			//no devices discovered, the user must specify a hostname
+			if (args.count("hostname") == 0) continue;
+
+			//try to connect at the specified hostname
+			ctx = iio_create_network_context(args.at("hostname").c_str());
+			if (ctx == nullptr) continue; //failed to connect
+			options["hostname"] = args.at("hostname");
+
+			std::ostringstream label_str;
+			label_str << options["device"] << " #0 " << options["hostname"];
+			options["label"] = label_str.str();
+
+			results.push_back(options);
+			if (ctx != nullptr) iio_context_destroy(ctx);
+
+		} else {
+			for (int i = 0; i < ret; i++) {
+				ctx = iio_create_context_from_uri(iio_context_info_get_uri(info[i]));
+				if (ctx != nullptr) {
+					options["uri"] = std::string(iio_context_info_get_uri(info[i]));
+
+					// check if discovered libiio context can be a PlutoSDR (and not some other sensor),
+          // it must contain "ad9361-phy", "cf-ad9361-lpc" and "cf-ad9361-dds-core-lpc" devices
+					iio_device *dev = iio_context_find_device(ctx, "ad9361-phy");
+					iio_device *rx_dev = iio_context_find_device(ctx, "cf-ad9361-lpc");
+					iio_device *tx_dev = iio_context_find_device(ctx, "cf-ad9361-dds-core-lpc");
+
+					if (dev != nullptr && rx_dev != nullptr && tx_dev != nullptr) {
+						// if uri is specified in kwargs, discovered uri must match
+						if (args.count("uri") == 0 || options["uri"] == args.at("uri")) {
+							std::ostringstream label_str;
+							label_str << options["device"] << " #" << i << " " << options["uri"];
+							options["label"] = label_str.str();
+
+							results.push_back(options);
+						}
+					}
+
+					if (ctx != nullptr) iio_context_destroy(ctx);
+				}
+
+			}
+			iio_context_info_list_free(info);
+			iio_scan_context_destroy(scan_ctx);
+		}
+
+	}
 	return results;
 }
 
diff --git a/PlutoSDR_Settings.cpp b/PlutoSDR_Settings.cpp
index 5ed9fca..958f0ae 100644
--- a/PlutoSDR_Settings.cpp
+++ b/PlutoSDR_Settings.cpp
@@ -42,6 +42,7 @@ SoapyPlutoSDR::SoapyPlutoSDR( const SoapySDR::Kwargs &args ):
 	}
 
 	this->setAntenna(SOAPY_SDR_RX, 0, "A_BALANCED");
+	this->setGainMode(SOAPY_SDR_RX, 0, false);
 	this->setAntenna(SOAPY_SDR_TX, 0, "A");
 }
 
@@ -488,7 +489,7 @@ void SoapyPlutoSDR::setFrequency( const int direction, const size_t channel, con
 
 double SoapyPlutoSDR::getFrequency( const int direction, const size_t channel, const std::string &name ) const
 {
-  	long long freq;
+  	long long freq = 0;
 
 	if(direction==SOAPY_SDR_RX){
 
@@ -601,7 +602,7 @@ void SoapyPlutoSDR::setSampleRate( const int direction, const size_t channel, co
 
 double SoapyPlutoSDR::getSampleRate( const int direction, const size_t channel ) const
 {
-	long long samplerate;
+	long long samplerate = 0;
 
 	if(direction==SOAPY_SDR_RX){
 
@@ -643,6 +644,24 @@ std::vector<double> SoapyPlutoSDR::listSampleRates( const int direction, const s
 
 }
 
+SoapySDR::RangeList SoapyPlutoSDR::getSampleRateRange( const int direction, const size_t channel ) const
+{
+	SoapySDR::RangeList results;
+
+	// note that there are some gaps and rounding errors since we get truncated values form IIO
+	// e.g. 25e6/12 = 2083333.333 is read as 2083333 but written as 2083334
+#ifdef HAS_AD9361_IIO
+	// assume ad9361_set_bb_rate(), if available, will load x4 FIR as needed
+	// below 25e6/96 needs x8 decimation/interpolation and x4 FIR, minimum is 25e6/384
+	results.push_back(SoapySDR::Range(25e6 / 384, 61440000));
+#else
+	// sample rates below 25e6/12 need x8 decimation/interpolation (or x4 FIR to 25e6/48)
+	results.push_back(SoapySDR::Range(25e6 / 96, 61440000));
+#endif
+
+	return results;
+}
+
 void SoapyPlutoSDR::setBandwidth( const int direction, const size_t channel, const double bw )
 {
 	long long bandwidth = (long long) bw;
@@ -660,7 +679,7 @@ void SoapyPlutoSDR::setBandwidth( const int direction, const size_t channel, con
 
 double SoapyPlutoSDR::getBandwidth( const int direction, const size_t channel ) const
 {
-    long long bandwidth;
+    long long bandwidth = 0;
 
 	if(direction==SOAPY_SDR_RX){
         std::lock_guard<pluto_spin_mutex> lock(rx_device_mutex);
diff --git a/PlutoSDR_Streaming.cpp b/PlutoSDR_Streaming.cpp
index ac05cbd..38db859 100644
--- a/PlutoSDR_Streaming.cpp
+++ b/PlutoSDR_Streaming.cpp
@@ -447,15 +447,14 @@ size_t rx_streamer::recv(void * const *buffs,
 			unsigned int index = i / 2;
 
 			uint8_t *src = (uint8_t *)iio_buffer_first(buf, chn) + byte_offset;
-			int16_t const *src_ptr = (int16_t *)src;
 
 			if (format == PLUTO_SDR_CS16) {
 
 				int16_t *dst_cs16 = (int16_t *)buffs[index];
 
 				for (size_t j = 0; j < items; ++j) {
-					iio_channel_convert(chn, conv_ptr, src_ptr);
-					src_ptr += buf_step;
+					iio_channel_convert(chn, conv_ptr, src);
+					src += buf_step;
 					dst_cs16[j * 2 + i] = conv;
 				}
 			}
@@ -464,8 +463,8 @@ size_t rx_streamer::recv(void * const *buffs,
 				float *dst_cf32 = (float *)buffs[index];
 
 				for (size_t j = 0; j < items; ++j) {
-					iio_channel_convert(chn, conv_ptr, src_ptr);
-					src_ptr += buf_step;
+					iio_channel_convert(chn, conv_ptr, src);
+					src += buf_step;
 					dst_cf32[j * 2 + i] = float(conv) / 2048.0f;
 				}
 			}
@@ -474,8 +473,8 @@ size_t rx_streamer::recv(void * const *buffs,
 				int8_t *dst_cs8 = (int8_t *)buffs[index];
 
 				for (size_t j = 0; j < items; ++j) {
-					iio_channel_convert(chn, conv_ptr, src_ptr);
-					src_ptr += buf_step;
+					iio_channel_convert(chn, conv_ptr, src);
+					src += buf_step;
 					dst_cs8[j * 2 + i] = int8_t(conv >> 4);
 				}
 			}
@@ -645,19 +644,17 @@ int tx_streamer::send(	const void * const *buffs,
 
 	int16_t src = 0;
 	int16_t const *src_ptr = &src;
-	uint8_t *dst_ptr;
-	ptrdiff_t buf_step = iio_buffer_step(buf);
+	ptrdiff_t buf_step = iio_buffer_step(buf); //in bytes
 
 	if (direct_copy && format == PLUTO_SDR_CS16) {
 		// optimize for single TX, 2 channel (I/Q), same endianess direct copy
-		dst_ptr = (uint8_t *)iio_buffer_start(buf) + items_in_buf * 2 * sizeof(int16_t);
-
+		int16_t *dst_ptr = (int16_t *)iio_buffer_start(buf) + items_in_buf * 2;
 		memcpy(dst_ptr, buffs[0], 2 * sizeof(int16_t) * items);
 	}
 	else if (direct_copy && format == PLUTO_SDR_CS12) {
 
-		dst_ptr = (uint8_t *)iio_buffer_start(buf) + items_in_buf * 2 * sizeof(int16_t);
-		int8_t *samples_cs12 = (int8_t *)buffs[0];
+		int16_t *dst_ptr = (int16_t *)iio_buffer_start(buf) + items_in_buf * 2;
+		uint8_t const *samples_cs12 = (uint8_t *)buffs[0];
 
 		for (size_t index = 0; index < items; ++index) {
 			// consume 24 bit (iiqIQQ)
@@ -672,6 +669,19 @@ int tx_streamer::send(	const void * const *buffs,
 			dst_ptr++;
 		}
 	}
+	else if (direct_copy && format == PLUTO_SDR_CS8) {
+
+		int16_t *dst_ptr = (int16_t *)iio_buffer_start(buf) + items_in_buf * 2;
+		int8_t const *samples_cs8 = (int8_t *)buffs[0];
+
+		for (size_t index = 0; index < items * 2; ++index) {
+			// consume (2x) 8bit (IQ)
+			// produce (2x) 16 bit, note the output is MSB aligned, scale=32768
+			*dst_ptr = int16_t(*samples_cs8) << 8;
+			samples_cs8++;
+			dst_ptr++;
+		}
+	}
 	else if (format == PLUTO_SDR_CS12) {
 		SoapySDR_logf(SOAPY_SDR_ERROR, "CS12 not available with this endianess or channel layout");
 		throw std::runtime_error("CS12 not available with this endianess or channel layout");
@@ -682,7 +692,7 @@ int tx_streamer::send(	const void * const *buffs,
 		iio_channel *chn = channel_list[k];
 		unsigned int index = k / 2;
 
-		dst_ptr = (uint8_t *)iio_buffer_first(buf, chn) + items_in_buf * buf_step;
+		uint8_t *dst_ptr = (uint8_t *)iio_buffer_first(buf, chn) + items_in_buf * buf_step;
 
 		// note that TX expects samples MSB aligned, unlike RX which is LSB aligned
 		if (format == PLUTO_SDR_CS16) {
diff --git a/README.md b/README.md
index 2632615..c2bece8 100644
--- a/README.md
+++ b/README.md
@@ -22,6 +22,17 @@ sudo make install
 
 * https://github.com/pothosware/SoapyPlutoSDR/wiki
 
+Note that the Frequency Correction API is not implemented,
+it's recommended that you adjust the `xo_correction` value with the observed PPM in the Pluto device `config.txt`.
+
+## PothosSDR
+
+Note that installation with PothosSDR is optional as "PlutoSDR SoapySDR binding (experimental)" and not selected by default.
+
+This is due to possible problems with other libusb devices,
+see [#24](https://github.com/pothosware/SoapyPlutoSDR/issues/24)
+and [libiio#586](https://github.com/analogdevicesinc/libiio/issues/586)
+
 ## Licensing information
 
 GNU LESSER GENERAL PUBLIC LICENSE Version 2.1, February 1999
diff --git a/SoapyPlutoSDR.hpp b/SoapyPlutoSDR.hpp
index 64271b6..1c5ee5d 100644
--- a/SoapyPlutoSDR.hpp
+++ b/SoapyPlutoSDR.hpp
@@ -6,6 +6,7 @@
 #include <atomic>
 #include <SoapySDR/Device.hpp>
 #include <SoapySDR/Logger.hpp>
+#include <SoapySDR/Types.hpp>
 #include <SoapySDR/Formats.hpp>
 
 typedef enum plutosdrStreamFormat {
@@ -296,7 +297,7 @@ class SoapyPlutoSDR : public SoapySDR::Device{
 
 		std::vector<double> listBandwidths( const int direction, const size_t channel ) const;
 
-       
+		SoapySDR::RangeList getSampleRateRange(const int direction, const size_t channel) const;
 
 	private:
 
diff --git a/cmake/cmake_uninstall.cmake.in b/cmake/cmake_uninstall.cmake.in
new file mode 100644
index 0000000..2037e36
--- /dev/null
+++ b/cmake/cmake_uninstall.cmake.in
@@ -0,0 +1,21 @@
+if(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
+  message(FATAL_ERROR "Cannot find install manifest: @CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
+endif(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
+
+file(READ "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt" files)
+string(REGEX REPLACE "\n" ";" files "${files}")
+foreach(file ${files})
+  message(STATUS "Uninstalling $ENV{DESTDIR}${file}")
+  if(IS_SYMLINK "$ENV{DESTDIR}${file}" OR EXISTS "$ENV{DESTDIR}${file}")
+    exec_program(
+      "@CMAKE_COMMAND@" ARGS "-E remove \"$ENV{DESTDIR}${file}\""
+      OUTPUT_VARIABLE rm_out
+      RETURN_VALUE rm_retval
+      )
+    if(NOT "${rm_retval}" STREQUAL 0)
+      message(FATAL_ERROR "Problem when removing $ENV{DESTDIR}${file}")
+    endif(NOT "${rm_retval}" STREQUAL 0)
+  else(IS_SYMLINK "$ENV{DESTDIR}${file}" OR EXISTS "$ENV{DESTDIR}${file}")
+    message(STATUS "File $ENV{DESTDIR}${file} does not exist.")
+  endif(IS_SYMLINK "$ENV{DESTDIR}${file}" OR EXISTS "$ENV{DESTDIR}${file}")
+endforeach(file)
-- 
2.42.0

